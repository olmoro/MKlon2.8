  Как задать новую команду обмена с драйвером и её исполнить.

  1. В файле mcmd.h выбрать незанятый код в диапазоне 0x10 ... 0x7F и задать имя, 
  например cmd_name, по которому в дальнейшем будет вызываться на исполнение команда 
  и проверяться ответ от драйвера.

  2. В классе MCommands (файл mcommands.h) в private объявите соответствующую функцию, 
  например doNameFunc(), которую в свою очередь в функции doCommand() (файл mcommands.cpp) 
  включите в конструкцию switch-case.

  3. В тот же класс MCommands вставьте определение объявленной функции, например:

      void MCommands::doNameFunc()
      {
        int id = 0;
        id = Wake->replyU08( id, Tools->param_1 );
        id = Wake->replyU16( id, Tools->раram_2 );
        id = Wake->replyU16( id, Tools->param_3 );
        Wake->configAsk( id, MCmd::cmd_name);
      }

      где      id - индекс для автоматического подсчета числа отправляемых байт;
          раram_n - целочисленный параметр;
      replyUxx() - функции преобразования параметров в байты команды;
      configAsk() - функция формирования команды по протоколу Wake.

4. В классе MTools (файл mtools.h) в public объявите функцию, которая будет использоваться 
при реализации целевых алгоритмов пользователя, не посвященного в тонкости обмена с драйвером, 
например:
void txNameFunc(char p1, float p2, float p3);

5. В тот же класс MTools (файл mtools.cpp) вставьте определение объявленной функции, 
например:

      void MTools::NameFunc(char p1, float p2, float p3)
      {
        param_1 = m;
        param_2 = (unsigned short) (p2 * pMult);
        param_3 = (unsigned short)((p3 * pMult) / hz);
        buffCmd = MCmd::cmd_name;                              
      }

      где param_n - объявленный ранее в классе MTools, public параметр;
      buffCmd - там же буфер для очередного вызова команды, когда представится
      такая возможность;
      (unsigned short) (p2 * pMult) - пример преобразования в целочисленное.

6. И наконец надо обработать ответ. Это возложено на функцию упомянутого выше класса 
MCommands:   
        short MCommands::dataProcessing(),
где в конструкцию switch-case вставьте соответствующую обработку. Функция возвращает 0, 
если отправленный пакет получен и обработан, или иное, если что-то пошло не так.


==========================================================================================

MKlon2. Как это работает. Межпроцессорный обмен.
   
  Связь между управляющим и измерительным контроллерами в части физического интерфейса 
состоялся в пользу UART, аппаратная реализация которого намного проще, чем прожорливый 
и склонный к "неожиданностям" капризный I2C. 
  На логическом уровне обмена данными существуют различные протоколы, но они обычно 
избыточны для реализации управления простыми микроконтроллерными устройствами, а потому 
применять такие протоколы не имеет смысла и выбор пал на протокол Wake, который был создан 
специально для реализации такой связи. Протокол используется в разработанном мною 
контроллере климат-контроля базовых станций сотовой связи (две МЕГИ-88) и доказал 
свою надежность, работая в режиме 24/7 уже более 10 лет (несколько тысяч экземпляров).
  Для надежного обнаружения начала пакета в потоке данных протокол Wake использует 
специальный зарезервированный символ, который в потоке данных встречаться не может. При 
необходимости передачи такого символа он заменяется последовательностью из двух символов 
(используется так называемый байт-стаффинг).
  Обмен идет посылками на скорости 230400 бод. Формат посылки (команды), как запроса, 
так и ответа выбран таким, чтобы укладываться в отведенные 500-600 микросекунд между 
регулярными циклами (1кГц) измерений тока и напряжения, включающих регулирование,  
обработку перегрузок и т.п. В пересчете на байты это не более 6-8 байт данных плюс 4 
служебных (стартовый, код команды, число байт и контрольная сумма пакета) и ещё должен 
быть запас на возможный байт-стаффинг. Данные передаются только как целочисленные и 
только один раз за 100 мс.
  Управляющий ESP32, если нет запроса на посылку целевой команды, отправляет запрос на 
получение данных от измерителя (2 байта напряжения и 2 байта тока) и 2 байта состояния 
SAMD21. Напряжение и ток в физических единицах - милливольтах и миллиамперах со знаком.
А два байта состояния дают исчерпывающие данные для управления процессом, учитывая то, 
что весь "реал-тайм" исполняется контроллером SAMD21 и не требует "мгновенного" 
вмешательства управляющего ESP32 в процесс целевой командой. В таком случае одно 
измерение из 100 заменяется предыдущим, что практически не заметно при визуализации как 
на дисплее, так и браузере.
