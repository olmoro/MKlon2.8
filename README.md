# <p align="center"> MKlon2.8
# <p align="center">Реализация конечного автомата в проекте зарядного устройства.
## <p align="center">Модульное зарядное устройство на ESP-WROOM-32D 
## <p align="center">проект Arduino.
#### <p align="right">редакция от 7 марта 2023 года

![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/IMG_20230215_111532_MP.png)

![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/IMG_20230215_171011_MP.png)

### MKlon2 - это проект для тех, кто наигрался с прошивками и профилями, а дух исследователя подгоняет продолжать поиски новых решений вплоть до реализации собственных алгоритмов. Сможете написать программу для елочной гирлянды на Arduino, или у вас есть рядом юное дарование, которое надо чем-то увлечь? имеете навыки пайки печатных плат с элементами SMD? у вас есть ЗУ типа Кулон, который вам уже скучен урезанным функционалом, но выводить его надолго из строя как-то не хочется? - тогда это для вас. Воплотив свою мечту заменяете начинку корпуса и наслаждаетесь. По сути предлагается своего рода глубокий "рестайлинг" Кулона, то есть возможность вдохнуть больше жизни в прибор убрав ненужное и добавив актуальное. Точно знаете что и как хотите реализовать, тогда вперёд. В отличие от Кулона MKlon2 не включается непосредственно в сеть 220 вольт и это должно вас порадовать, как это радует меня. А те программисты, которые захотят пополнить свой арсенал, найдут ещё один неочевидный вариант реализации конечного автомата (FSM) с использованием виртуальной функции, и совсем не обязательно это будет зарядное устройство... 

1. [Как это работает](#mklon)
2. [Аппаратный аспект](#hardware)
    - [Платформа](#hard_platform)
    - [Модули](#modules)
        - [Управление](#control)
        - [Индикация](#lcd)
        - [Измерение](#measure)
        - [Регулирование](#adjusting)
        - [Питание](#power)
        - [Таймер](#timer)
    - [Клавиатура](#key)
    - [Датчики](#sensor)
    - [Диагностика](#diagnostics)
    - [Подключение батареи](#connecting)
    - [Система охлаждения](#cool)
    - [Разряд](#discharge)
    - [1-WIRE шина](#onewire)
    - [Защита](#protection)
        - [Переполюсовка](#reverse_polarity)
        - [Перегрузка](#overload)
        - [Искрогашение](#spark)
    - [По мелочи](#small)

3. [Программный аспект](#soft)
    - [Платформа](#soft_platform)
    - [Дисплей](#128x160)
    - [Клавиатура](#button)
    - [ПИД-регулятор](#pid)
    - [Сеть](#connect)
    - [Протокол обмена](#wake)
    - [Команды](#commands)
    - [АЦП](#adc)
    - [Утилиты](#tools)
4. [Технические характеристики](#specifications)
5. [FSM](#fsm)
6. [Полезные ссылки](#useful_links)
7. [About Me](#about)
***
## <p align="center"> Как это работает.
В зарядном устройстве пользовательский интерфейс реализован на модуле с ESP32 (ESP), а управление силовым блоком производится по последовательному каналу. На ESP обслуживается клавиатура, дисплей, RGB индикатор, зуммер, система контроля питания, датчики температуры, система охлаждения, интерфейс драйвера силового блока, часики бортового времени, USB, WiFi, BT. В памяти ESP хранятся заводские и пользовательские настройки. Оператору предоставляется возможность выбрать посредством меню требуемый режим работы, задать параметры и запустить. Настройки беспроводной сети позволяют в реальном времени на удаленном компьютере не только наблюдать в виде графиков процесс: напряжение, ток, баланс заряда/разряда, температуру, работу системы охлаждения, но и управлять им. Программное обеспечение ESP построено таким образом, что позволяет даже непрофессиональному программисту реализовать свой собственный алгоритм, воспользовавшись методикой из репозитория FSM (собственно ради этого и задумывался проект).

Драйвер силового блока (DRV) как таковой может отсутствовать - свободных ресурсов ESP достаточно, а INA226, ADS1115 можно подключить к последовательному каналу, установив свой модуль. Но здесь представлен более интересный вариант, когда весь, или почти весь реалтайм реализован на отдельном модуле SAMD21 MINI (D21). Связь c ESP осуществляется по асинхронному каналу. Модуль D21 получает команду, по которой включаются соответствующие ресурсы: АЦП тока и напряжения, ШИМ-генератор, ЦАП управления разрядом, коммутатор выхода и др. Автоматически поддерживается устойчивость силового преобразователя при работе на малую нагрузку или на холостом ходе, отключение при перегрузках. Поддерживается режим быстрого разряда накопительных конденсаторов через нагрузку для разряда, минуя датчик тока, дабы не искажать подсчет ампер-часов. Когда возможно допускается регулировка параметров "на лету", иначе D21 переводит силовую часть в безопасный режим с выдачей сообщения управляющему контроллеру. D21 поддерживает управление зарядом и разрядом как командами, так и с помощью собственного ПИД-регулятора. Настройки коэффициентов для поддержания тока и напряжения могут быть разные. Выбор ПИД-регулирования имеет 4 режима: отключено, по току, по напряжению и с автовыбором по типу реализованного в TL494. Измерения напряжения на батарее производятся по четырехпроводной схеме в диапазоне от -2 до +18 вольт. Ток разряда измеряется на том же шунте, что и ток заряда от -10 до +10 ампер. Параметры фильтрации измерений задаются командами.

Питание прибора производится от внешнего AC/DC преобразователя (БП) на 18...19 вольт 6...9 ампер, что определяет выходные параметры зарядного устройства и делает само устройство с точки зрения электробезопасности более привлекательным.

***
Межпроцессорное соединение. 
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/interprocessor.png)

MKlon2. Как это работает.

Здесь реализована как минимум одна хитрость: модуль SAMD21 MINI запитан от изолированного источника питания со смещением в "минус" примерно на 200 милливольт, необходимые для дифференциальных измерений напряжения и тока. При реализованной топологии печатной платы существенного влияния на обмен по асинхронному интерфейсу не обнаружено.

Однако есть и недостаток: при одновременном подключении к одному компьютеру обоих USB указанное смещение становится равным нулю. И в результате как напряжение, так и ток отрицательной полярности при любом их значении индицируются вблизи нуля. Всё бы ничего, но в режиме разряда PID-регулятор поддержания установленного тока просто "сходит с ума" - всё добавляет и добавляет, пока ток не "упрется" в максимум, определённый сопротивлением нагрузки.

Но до этого, думаю, дело не дойдёт - это ж надо быть каким крутым программистом, чтобы одновременно кодировать два разных проекта...

Активным в связке является ESP32, который генерирует запрос по асинхронному интерфейсу. Линия READY - резервная, При экспериментах служит для синхронизации логического анализатора.

***
MKlon2. Как это работает. Межпроцессорный обмен.
   
  Связь между управляющим и измерительным контроллерами в части физического интерфейса 
состоялась в пользу UART, аппаратная реализация которого намного проще, чем прожорливый 
и склонный к "неожиданностям" капризный I2C. 
  На логическом уровне обмена данными существуют различные протоколы, но они обычно 
избыточны для реализации управления простыми микроконтроллерными устройствами, а потому 
применять такие протоколы не имеет смысла и выбор пал на протокол Wake, который был создан 
специально для реализации такой связи. Протокол используется в разработанном мною 
контроллере климат-контроля базовых станций сотовой связи (две МЕГИ-88) и доказал 
свою надежность, работая в режиме 24/7 уже более 10 лет (несколько тысяч экземпляров).
  Для надежного обнаружения начала пакета в потоке данных протокол Wake использует 
специальный зарезервированный символ, который в потоке данных встречаться не может. При 
необходимости передачи такого символа он заменяется последовательностью из двух символов 
(используется так называемый байт-стаффинг).
  Обмен идет посылками на скорости 230400 бод. Формат посылки (команды), как запроса, 
так и ответа выбран таким, чтобы укладываться в отведенные 500-600 микросекунд между 
регулярными циклами (1кГц) измерений тока и напряжения, включающих регулирование,  
обработку перегрузок и т.п. В пересчете на байты это не более 6-8 байт данных плюс 4 
служебных (стартовый, код команды, число байт и контрольная сумма пакета) и ещё должен 
быть запас на возможный байт-стаффинг. Данные передаются только как целочисленные и 
только один раз за 100 мс.
  Управляющий ESP32, если нет запроса на посылку целевой команды, отправляет запрос на 
получение данных от измерителя (2 байта напряжения и 2 байта тока) и 2 байта состояния 
SAMD21. Напряжение и ток в физических единицах - милливольтах и миллиамперах со знаком.
А два байта состояния дают исчерпывающие данные для управления процессом, учитывая то, 
что весь "реал-тайм" исполняется контроллером SAMD21 и не требует "мгновенного" 
вмешательства управляющего ESP32 в процесс целевой командой. А в таком случае одно 
измерение из 100 заменяется предыдущим, что практически не заметно при визуализации как 
на дисплее, так и браузере.

***
 Измерители.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/ui_measure.png)

MKlon2. Как это работает.

Измерение напряжения и тока по дифференциальной схеме. Микроконтроллер SAMD21 предоставляет такую возможность. Только следует учесть, что 12-разрядный АЦП становится фактически 11-разрядным плюс знаковый разряд. И рассчитывая параметры шунта и делителя напряжения следует оперировать половинным значением опорного напряжения. Не забывайте о низкочастотных фильтрах и  диодах защиты. А чтобы при манипулировании с "крокодилами" вход измерителя напряжения не повисал неподключенным, одноимённые силовой и измерительный провод соедините резисторами (на схеме не показаны). Спросите и что же получается ... 20 000 милливольт или миллиампер делим на 2^11 (2048) ... 10. Многовато будет. Не волнуйтесь, аналого-цифровой преобразователь SAMD21 при правильной настройке (а там и автокомпенсация смещения, и усилитель с фильтом, и накопитель с вычислителем среднего значения ... но об этом потом) только мне надо было уложиться сеансом измерения напряжения и тока по 25 микросекунд максимум и иметь на выходе 16 разрядов, включая знаковый, а качество сглаживания за сеанс (примерно 5 периодов DC 190 килогерц) и вычисление скользящего среднего за 100 сеансов вполне достаточным для регулирования с частотой 10 герц.

***
Вычисление среднего.

MKlon2. Как это работает.

Не вызывает никаких сомнений метод вычисления среднего за определенный интервал, когда сумму измерений делят на их число. Однако для получения следующего среднего придется всё повторить с начала, и на это потребуется время. Но есть метод, когда на следующем цикле измерения убирается (вычитается) самый ранний уровень и добавляется (прибавляется) новый, а затем вычисляется среднее. Всё бы хорошо, но чтобы сохранить все эти уровни может потребоваться немалый расход памяти. Есть метод, позволяющий устранить этот недостаток, заменив вычитаемый ранний уровень средним значением, и называется он скользящим средним. Наибольший выигрыш дает не произвольное число измерений (k), а кратное степеням двойки: 2, 4, 8, 16, когда можно операцию деления заменить арифметическим сдвигом. Соответственно буфер (sum) для накопления должен иметь такое число разрядов, чтобы не возникало переполнения. Функция вычисления для 16-разрядного ADC может выглядеть так:

int16_t averageU(uint8_t k) 
{
  static int32_t sum = 0;  // объявили и инициализировали сумматор удвоенной, чем ADC разрядности 
  int16_t avrU = sum >> k;  // вычислили среднее за прошлый интервал (накопленное поделили на число измерений)
  sum += adcU - avrU;    // к сумматору добавили разность между новым измерением и средним
  return int16_t(sum >> k);  // вернули новое значение среднего
}

То есть среднее равно (sum += adcU - (sum >> k)) >> k

В этом проекте одновременно с подсчетом среднего производится преобразование 12-разрядного ADC в 16-разрядный с помощью простого приема, для этого при вычислении среднего за прошлый интервал результат сдвигается на k плюс число недостающих разрядов ADC, то есть на k + 4. 
Внимание! Будьте внимательны со скобками - в C++ приоритеты примененных здесь операций в порядке убывания: ()  -  >>  +=  .

А есть ли у метода "скользящее среднее" недостаток? Есть, в начальный период, пока сумматор не накопит достаточного количества измерений, значение среднего может оказаться существенно меньшим, чем реальное значение. Но и здесь не всё так печально. Во-первых, это можно использовать в мирных целях, например для "мягкого старта" системы регулирования. А во-вторых, объявляя сумматор, инициализировать не нулем, а некоторой величиной, например при измерении температуры радиатора задать величину, соответствующую температуре окружающей среды, не забыв сдвинуть влево на "k" разрядов. Для измерителя напряжения ЗУ - около 12 вольт. Так сумматор быстрее наберёт необходимое число измерений.

***
 Схема разряда.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/i_discharge.png)

MKlon2. Как это работает.

Измерение тока разряда производится на том же шунте RS, что и ток заряда, исключая неоднозначность при подсчете залитых и слитых ампер-часов. Для облегчения теплового режима предусмотрен разъем для подключения внешней нагрузки. В случае отсутствия таковой ток ограничивается двух-ваттным резистором R54. В режиме заряда при чрезмерно малой нагрузке силовой DC/DC автоматически подгружается этим резистором для обеспечения его устойчивой работы, причем этот ток не фиксируется шунтом, а потому не вносит погрешности в подсчет ампер-часов.

В качестве внешней нагрузки подключалась лампа накаливания. Если задавать ток разряда несколько больший, чем ток полного накала, параллельно через автомобильное ЗУ заряжается смартфон, что позволяет утилизировать отдаваемый заряд с пользой.

Не без некоторого содрогания во время разряда отключался источник питания - как от сети, так и по 19 вольтам - полет нормальный, лишь слегка понизились обороты вентилятора.

***
Подключение заряжаемой батареи.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/switch.png)

MKlon2. Как это работает.  

Здесь ничего нового - схема "цельнотянутая" с прототипа, коим является Кулон 912 и 920-й. Даже предохранитель и 300-амперный диод защиты от повреждения электролитических конденсаторов силового преобразователя при переполюсовке вписались как родные. Но это не более чем перестраховка - при разработке всякое может случиться. Последний барьер не помешает. В качестве ключей применены HEXFET МОП-транзисторы IRLR2905 с высокой скоростью переключения и повышенной лавиноустойчивостью, а также имеющие возможность управляться логическим уровнем. То есть оба изолированных источника в приборе могут быть 5-вольтовые. Посмотрим, оправдается ли такой выбор. Управление ключами производится через оптопару, вносящей, к сожалению, слишком большую задержку - порядка 25 микросекунд, и это может стать проблемой.

***
 Питание микроконтроллеров.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/power.png)

MKlon2. Как это работает.

Питание модулей и схемы подключения батареи, коей нужна "дежурка", и не простая, а с гальваноразвязкой. Оказалось, что это достаточно просто получить, используя 1-ваттный преобразователь из 5 вольт входных в 12 вольт выходных. Аналогичный DC/DC на 5 вольт выходных используется для питания измерительного модуля SAMD21 со сдвигом на 200 милливольт в минус от общего провода силового ИП. Эти пребразователи не имеют встроенного стабилизатора, но в обоих случаях это и не требуется. Подключение же их произведено со всеми рекомендациями - самовосстанавливающийся предохранитель на входе, LC-фильтры по входу и выходу, резисторы нагрузки и конденсатор между предполагаемыми "холодными" концами обмоток. 

VD6 следует выбирать с минимальным обратным током, в лучшем случае он добавит пару милливольт к разности напряжений на клеммах. 

Это особенность или я что-то делал не так? Самовосстанавливающийся предохранитель MF на 200мА до пайки имеет сопротивление менее 2-х Ом, а после - почти 6. Может быть придется повысить выходное напряжение источника на MC34063 с 5 до 5,5 вольт.

Для питания модуля ESP32-WROOM-32D необходим источник на 3.3 вольта и ток не менее 0.5 ампера. Особо не мудрствуя повторил схему, реализованную в модулях с платами версий 1 и 4 (30 и 38 пиновые соответственно). При их использовании схема упрощается - 5 или 5.5 вольт подаются непосредственно на Vin.

***
 Силовой DC/DC преобразователь.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/dc_dc.png?raw=true)

MKlon2. Как это работает.

Выбрана схема преобразователя с P-MOSFET IRFP9140 и драйвером MIC4420 как вполне достаточная, чтобы получить возможность отладки алгоритмов управления, оставляя на будущее масштабирование вольтамперных  характеристик. В качестве "донора" был выбран [XL4016 DC-DC Max 9A 300W](https://aliexpress.ru/item/32661166685.html?_ga=2.264151500.1168692661.1643047564-769654542.1642920280&sku_id=12000020944321893&spm=a2g39.orderlist.0.0.60754aa6RxSv8u), силовые компоненты которого, кроме 4016, были перенесены на плату прибора. Рабочая частота была воспроизведена путем настройки режима работы таймера SAMD21. Несмотря на относительно высокую частоту микроконтроллера (48МГЦ) и турбо-режим (72МГц) удалось получить лишь 9-разрядный выход 190-килогерцового ШИМа. Вкупе с ПИД-регулятором это обеспечивает заявленные дискретности установки тока и напряжения 10 мА и 10 мВ.

Особое внимание уделено выбору резистора в цепи затвора P-MOSFET. Рекомендованные 25 Ом для IRFP9140 оказались слишком малы для нормальной работы драйвера - затвор присланных с Ali экземпляров оказался слишком "тяжёл". Вместо заявленных 1400 пФ емкость затвор-исток оказалось вдвое больше, что само по себе странность, обычно бывает наоборот. Короче, драйверу его одного ватта выходной мощности оказалось маловато и в процессе экспериментов при попытке загнать регулятор в колебательный режим он испустил дымок. В итоге номинал резистора в прямом направлении был увеличен до 43 Ом (33 + 10).

Кратко выбор резистора в цепи затвора определяется следующими требованиями:
1. ограничение тока драйвера (ниже допустимого для драйвера) при переключениях
2. ограничение скорости изменения напряжения на стоке, дабы не привести к броскам напряжения на затворе через емкость Миллера с возможным повреждением затвора и драйвера высоким напряжением.
3. ограничение добротности затворной цепи, то есть колебательного контура, образованного емкостью затвора и паразитными индуктивностями проводников между драйвером затвора и самим кристаллом МОСФЕТа. Ибо высокодобротная цепь приводит к резонансным выбросам на затворе и возможности повреждения высоким напряжением как самого затвора, так и драйвера.

О резисторе на входе драйвера. Выяснилось, что в процессе работы может последовать включение питания без модуля SAMD21, и, чтобы избежать неконтролируемого напряжения на выходе преобразователя, пришлось подтянуть оказавшийся "в воздухе" вход к плюсу питания. Естественно, что если применен инвертирующий драйвер типа MIC4429, то вход надо подтянуть к общему проводу.

Влияние высокочастотного RC фильтра для подавления высокочастотных колебаний не исследовалось.

Топология печатной платы разработана так, что допускается установка компонентов для увеличения отдаваемой мощности.

***
 Подключение вентилятора.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/cooler.png)

MKlon2. Как это работает.

В своё время немало копий было сломано на просторах https://electrotransport.ru/ussr/index.php?msg=754026 по поводу правильного управления вентилятором в кулонах. В основном критике подвергалась простейшая схема из транзистора и электролитического конденсатора. В этом проекте схема в основном повторяет силовой преобразователь с ограничением мощности до примерно 2-х ватт, достаточных для 60-мм вентилятора.

Система управления охлаждения охвачена обратной связью через датчик температуры типа NTC, установленный на радиаторе. Были испытаны два варианта реализации - на управляющем модуле ESP или на измерительном SAMD. Взвесив все за и против был выбран первый, дабы не грузить одноядерный микроконтроллер второстепенными задачами.

Напряжение, подаваемое на вентилятор, управляется ПИД-регулятором. Порог температуры и коэффициенты Kp, Ki и Kd задаются настройками: 
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/PID_Compensation_Animated.gif)
Как видно из иллюстрации, можно задать как ленивый, так и агрессивный характер системы. Мне понравился агрессивный, он же с перерегулированием - как только температура превысит порог, быстро её "сдуть" типа как бы чего не вышло, и через несколько таких включений-выключений установится некая средняя скорость вентилятора для поддержания температуры на заданном уровне. Лишний шум? Резинок не было, поставил на двусторонний строительный скотч, и все дела...
***
 USB интерфейс.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/usb.png)

MKlon2. Как это работает.


***

Дисплей
***

One-Wire интерфейс
***

RGB светодиод, зуммер, клавиатура
*** 
Преобразование данных АЦП в напряжение с коррекцией (не)линейности

![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/ADC-non-linear-ESP32.webp)
К сожалению ADC ESP32 не слишком хорош для точных измерений. Но не всё так печально - (не)линейность имеет системный характер, то есть описывается формулой. Приведённая ниже реализация позволяет уменьшить погрешность измерений температуры радиатора и напряжения источника питания 
до вполне приемлемого 1%.

Хитрость реализации состоит в том, что не используется функция возведения в степень, пожирающая вычислительный ресурс (конечно, если она используется только здесь).

float MBoard::readVoltage( int adc ) {

  // Reference voltage is 3v3 = 4095 in range 0 to 4095

  if ( adc < 1 || adc >= 4095 ) return 0;

  const float adc2 = adc  * adc;

  const float adc3 = adc2 * adc;

  return -0.000000000000016f * adc3 * adc

  \+ 0.000000000118171f * adc3

  \- 0.000000301211691f * adc2

  \+ 0.001109019271794f * adc

  \+ 0.034143524634089f;

}

Получить свои параметры преобразования можно достаточно просто, сняв показания по точкам, введя в [онлайн-калькулятор](https://planetcalc.ru/5992/) и выбрав наиболее подходящую аппроксимацию. Только следите, чтобы средняя ошибка аппроксимации не превышала 10-12%, что будет считаться хорошим результатом вашей работы.

    Для публикации:
MKlon2. Как это работает.

Преобразование данных АЦП в напряжение с коррекцией (не)линейности.

При калибровке измерителя напряжения заметили досадную нелинейность? Не всё так печально. Приведённая ниже реализация позволяет уменьшить погрешность измерений. Для этого подключите на вход регулируемый источник и примерно через равные интервалы входного напряжения запишите полученные пары: что на входе, и что на выходе. Прибор должен быть прогрет. Затем введите в [онлайн-калькулятор](https://planetcalc.ru/5992/) эти пары и запустите "РАССЧИТАТЬ". По введенным точкам будут построены графики. Отбросьте те что вам не понравились, оставив максимально приближенные к вашим точкам. Если какие-то точки явно выбились - перемерьте эту пару. Не гонитесь за точной установкой входного напряжения - это ни к чему. Обращайте внимание на две вещи: края диапазона и "среднюю ошибку аппроксимации". Если на краях диапазона явно выраженная нелинейность, то эти пары следует исключить и подумать над схемотехникой измерителя, а вот средняя ошибка аппроксимации, не превышающая 10-12% будет соответствовать тому, что вы хорошо выполнили свою работу и можете рассчитывать на корректные данные для реализации.

Так, на чём мы остановились? Отключили ненужные варианты аппроксимации. Выберите ту регрессию, которая вам больше всего понравилась. Как вы уже догадались, формулу надо будет реализовать в коде. Меньше всего ресурса сожрёт линейная аппроксимация, чем степенная или логарифмическая.
Будет скомпенсирована не только нелинейность измерителя, но и сдвиг и коэффициент преобразования. Процесс калибровки прибора по напряжению на этом может быть закончен.

В качестве примера приведу коррекцию ADC ESP32:
float readVoltage( int adc ) {

  // Reference voltage is 3v3 = 4095 in range 0 to 4095

  if ( adc < 1 || adc >= 4095 ) return 0;

  const float adc2 = adc  * adc;

  const float adc3 = adc2 * adc;

  return -0.000000000000016f * adc3 * adc

  +0.000000000118171f * adc3

  -0.000000301211691f * adc2

  +0.001109019271794f * adc

  +0.034143524634089f;

}

Как видите, линейной аппроксимацией тут дело не обошлось, а возведение в степень заменено банальными умножениями. А всё дело в том, что у ESP32 мягко говоря кривенький АЦП. И на ночь показывать график не буду.




Хитрость реализации состоит в том, что не используется функция возведения в степень, пожирающая вычислительный ресурс (конечно, если она используется только здесь).

float readVoltage( int adc ) {

  // Reference voltage is 3v3 = 4095 in range 0 to 4095

  if ( adc < 1 || adc >= 4095 ) return 0;

  const float adc2 = adc  * adc;

  const float adc3 = adc2 * adc;

  return -0.000000000000016f * adc3 * adc

  +0.000000000118171f * adc3

  -0.000000301211691f * adc2

  +0.001109019271794f * adc

  +0.034143524634089f;

}

Получить свои параметры преобразования можно достаточно просто, сняв показания по точкам, введя в онлайн-калькулятор (https://planetcalc.ru/5992/) и выбрав наиболее подходящую аппроксимацию. Только следите, чтобы средняя ошибка аппроксимации не превышала 10-12%, что будет считаться хорошим результатом вашей работы.

***

Таймер РВ
***
MKlon2. Как это работает. Реализация FSM кратко на примере одного состояния.

[FSM](https://github.com/olmoro/MKlon2.8/blob/main/src/modes/cccv.txt)




***

1 марта проект переименован под плату версии MKlon2v8. По мере испытаний документация корректируется и выкладывается здесь. 

***
## <p align="center"> Аппаратный аспект <a name="hardware"></a>
### <p align="center">Платформа <a name="hard_platform"></a>
Arduino как аппаратная платформа предполагает модульный принцип построения системы (читай: многое уже сделано за нас, а если проблема решается за деньги, то это не проблема, а расходы)) - с этого и начнем... 
### <p align="center">Модули <a name="modules"></a>
#### Управление <a name="control"></a>
Управляющий модуль [ESP32-WROOM-32D](https://aliexpress.ru/item/32995519416.html?spm=a2g2w.orderdetails.0.0.1c024aa6EZlC3f&sku_id=10000000045993301&_ga=2.246283140.1610960066.1667852261-603987165.1661065985) на 4 или 16МБ распаян на плату. Питание модуля - DC/DC преобразователь на 5.5 вольт, далее через самовосстанавливающийся предохранитель. "где смешивается" схемой на диодах с напряжением, снимаемым с USB-разъёма Это позволяет при достаточной мощности, подводимой к разъему USB, производить работы на низковольтной части без подключения к внешнему источнику. Далее на LM1117 5 вольт понижается до требуемых 3.3 вольт. Такая схема вкупе с параметрами цепи сброса обеспечивает надёжный старт при подаче питания. Для программирования модуля используется упомянутый USB-интерфейс на CP2104. 
#### Индикация <a name="lcd"></a>
Модуль дисплея - полноцветный [TFT](https://aliexpress.ru/item/32996979276.html?spm=a2g2w.orderdetails.0.0.f9664aa6FFnV7N&sku_id=67278796295&_ga=2.258282378.1610960066.1667852261-603987165.1661065985) с подсветкой. На плате предусмотрена возможность подключения как 128х128, так и 128х160 варианта. Подключен по схеме SPI-3.
#### Измерение <a name="measure"></a>
Модуль измерения [WeMos SAMD21 M0 Mini](https://aliexpress.ru/item/4001074203011.html?_ga=2.268755377.1168692661.1643047564-769654542.1642920280&sku_id=10000014182967685&spm=a2g39.orderlist.0.0.60754aa6RxSv8u) съемный, устанавливается на цанговые [разъемы](https://www.chipdip.ru/product0/8002610753) или [панель](https://www.chipdip.ru/product/trl-28). Идущие в комплекте штыревые разъемы лучше не применять ввиду их ненадежности. Модуль размещен "в тени" обдувающего потока и имеет доступ к своему USB-MICRO с тыльной стороны прибора. Для питания модуля используется гальванически развязанный [источник](https://aliexpress.ru/item/1005003568781579.html?_ga=2.165478714.428003227.1651560775-769654542.1642920280&sku_id=12000026320337806&spm=a2g39.orderlist.0.0.50684aa6oqK3eu) на 5 вольт и мощностью 1 ватт. Связь с управляющим контроллером по асинхронному интерфейсу 230400 бод.
#### Регулирование <a name="adjusting"></a>
Силовой преобразователь [XL4016 DC-DC Max 9A 300W](https://aliexpress.ru/item/32661166685.html?_ga=2.264151500.1168692661.1643047564-769654542.1642920280&sku_id=12000020944321893&spm=a2g39.orderlist.0.0.60754aa6RxSv8u) был демонтирован и частично (электролитические конденсаторы и дроссель) перенесен на плату. Выбор в пользу P-канальной схемы преобразователя может показаться не самым оптимальным, но перевесило то, что при любом уровне входного сигнала максимум, что нас ожидает, это заряд конденсаторов до напряжения источника питания, а он предусмотрительно выбран на 18...19 вольт. И это хорошо сопрягается с параметрами P_MOSFET'а, драйвера MIC4420, да и с потребностями обеспечения заряда в разумных пределах.  
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/MIC4420.png)

А что будет, если подать питание на устройство без управляющего модуля? Не хотелось бы иметь заряженные конденсаторы, не правда ли? То есть факторов несколько, а что в арсенале? Задать полярность ШИМа, подтянуть вывод к питанию или земле, на худой конец заменить MIC4420 на MIC4429 (инвертирующую) - решено, см. схемы.

И ещё одно обстоятельство следует учесть: выбор доступных P-MOSFET по сравнению с N-, да ещё в корпусе ТО-247 я бы назвал "широко ограниченным". И пришлось довольствоваться тем, что удалось достать. Не самые оптимальные параметры, но примененные конструктивные и схемные решения позволяют нивелировать этот недостаток. Какие - станет ясно из изложенного ниже. 
#### Питание <a name="power"></a>
Модуль питания AC/DC на 6А внешний, например, [WX-DC2406](https://aliexpress.ru/item/1005001714079538.html?_ga=2.268223694.1168692661.1643047564-769654542.1642920280&sku_id=12000018559376968&spm=a2g39.orderlist.0.0.60754aa6RxSv8u), настроенный на выходное напряжение 18 вольт или аналогичный на 9А. Но лучше будет использовать ноутбучный - у меня TOP-AS180 101001 19V 9A. Дороже, зато не надо мудрить с "окорпусовыванием" WX. 

Вместо встроенной электронной нагрузки предлагается возможность подключения в режиме разряда нагрузки пользователя. Разъем от автомобильного "прикуривателя" на задней стенке прибора позволит подключить многое из арсенала автолюбителя - от лампы подсветки до USB-зарядки или DС/AC на 230 вольт выходного напряжения. Подкачать колеса вряд ли получится, но зарядить гаджет - вполне, и электричество не растратится впустую, и "зеленые" будут довольны.  
#### Таймер<a name="timer"></a>
Модуль [прецизионных часов](https://aliexpress.ru/item/32824174999.html?sku_id=64909286317&spm=.list.1.6cc1587eXZyGas) на DS3231 с батарейкой, лучше литиевой с возможностью подзаряда. Или же специальный модуль таймера со слотом для карты памяти формата MICRO, который ещё предстоит разработать. Попытка использовать модуль в качестве супервизора питания не удалась.
### <p align="center">Клавиатура <a name="key"></a>
Схема 5-кнопочной клавиатуры при нажатии выдает соответствующий уровень напряжения, причем резисторы подобраны таким образом, что опорное напряжение делится на равные доли. Выглядит довольно брутально, но кнопки можно выбрать и поизящнее. Подключение разъемом [6pin](https://aliexpress.ru/item/1005001530994945.html?sku_id=12000016489844779&spm=a2g2w.productlist.search_results.136.3ed74aa65LkFgb) с уже распаянными "хвостиками" разного цвета (цвет может совпадать с цветом кнопки ... прикольно!).
### <p align="center">Датчики <a name="sensor"></a>
Измерители напряжения и тока включены для дифференциальных измерений со смещением в разумных пределах общего провода в "минус", что позволяюет измерять напряжение и ток обеих полярностей. Этот "разумный предел" составляет 200 милливольт. Получается достаточно просто - падение напряжения на диоде Шоттки SS14 составляют те же 0,2 вольта. Это напряжение будет определять диапазон измерения тока разряда - при 20mV/A и будет до -10 ампер. Следует учесть, что эти 200 милливольт разделяют "земли" ESP32 и SAMD21. Долговременные испытания с прохождением нескольких сотен тысяч сеансов обмена по асинхронному интерфейсу на скорости 230400 бод не выявили ошибок. Так же, что очень странно, одновременное подключение к компьютеру двух USB не привело к печальным последствиям, однако использовать прибор по прямому назначению с подключением обоих USB не рекомендуется, так как исключается возможность измерения напряжения и тока обратной полярности.  
### <p align="center">Диагностика <a name="diagnostics"></a>
На плате имеются два разъёма для подключения 8-канального логического [анализатора](https://aliexpress.ru/item/1005004783286574.html?sku_id=12000030470334955&spm=a2g2w.productlist.list.6.4d1b5c5e8YmNAb) к некоторым цепям модулей ESP32 и SAMD21, что может быть весьма полезно при отладке устройства и разработки целевого ПО. Анализатор имеет 10-контактный разъем, и если установить ответный также на 10 контактов, то придется вслепую ловить удачу, а потому рекомендую поставить 14-контактную ["маму"](https://aliexpress.ru/item/1005004159749502.html?spm=a2g2w.productlist.search_results.2.53174aa6yjmSGb&sku_id=12000028233029364), удалив по 2 пары крайних контактов. Впрочем, при ошибке подключения ни прибору, ни анализатору вред нанесен не будет - лишь каналы на мониторе покинут привычные места.
### <p align="center">Подключение батареи <a name="connecting"></a>
Батарея подключается по четырехпроводной схеме, понижающей в значительной степени требования к качеству соединительных проводов и не только, а также исключающих их "калибровку". Но для этого потребуются соответствующие ["крокодилы"](https://aliexpress.ru/item/4000593884517.html?spm=a2g2w.orderdetails.0.0.777a4aa6ri0LqM&sku_id=12000020938249496&_ga=2.53804840.1610960066.1667852261-603987165.1661065985) с изолированными щёчками.
И проводов потребуется четыре вместо двух. Мне пришлось "колхозить", скрепляя через 150 мм термоусадкой попарно 12AWG(силовой) и 26AWG(сигнальный) красного и черного цветов в силиконовой изоляции. А хорошо бы найти такую комбинацию в общей оболочке для каждой пары. 
### <p align="center">Система охлаждения <a name="cool"></a>
Силовые элементы (все в TO-247, и тому есть объяснение), расположенные на одном общем радиаторе с термодатчиком [NTC 10ком](https://aliexpress.ru/item/1005003259717722.html?_randl_currency=RUB&_randl_shipto=RU&src=yandex&albch=search&aff_short_key=_eNJs8N&isdl=y&aff_platform=jvru&albcp=75406988&tracelog=yandex_jvru_pcon_75406988&albag=4944226149&albad=12297225520&netw=context&albkwd=1770354&albagn=pcon&acnt=86373530&cn=75406988&dp=7377683216933119280&feed_id=172&yclid=7377683216933119280&_1ld=3252257_1&utm_medium=cpc&utm_source=yandex&utm_campaign=JVRU_CM_ALI_YANDEX_WEBdesk_RU_CURRENT_SMART_CTGRiS_TOOLS_5WEBRMKT_0_0_0_0_&sku_id=12000025222878849), обдуваются 60х15 мм вентилятором на 12 вольт. Преобразование ШИМ выхода ESP в управляющее скоростью напряжение производится схемой на MIC4420. Оригинальное крепление двух TO-247 одним винтом на разных сторонах плоского радиатора объясняется тем, что они не работают одновременно, что вряд ли понравится почитателям рестайлинга. Радиатор заимствован с Кулона-912 и расположен точно по оси воздушного потока от вентилятора, что несколько их утешит... Для вентилятора 60 мм предусмотрена ниша глубиной 15 мм. В прототипе измерение температуры и управление вентилятора производилось измерительным модулем. Но окончательное решение состоялось в пользу "независимого", насколько это возможно, мониторинга - модуля ESP32. 
### <p align="center">Разряд <a name="discharge"></a>
Схема разряда предусматривает возможность подключения внешней нагрузки для облегчения теплового режима прибора. На задней стенке прибора установлен [разъём](https://aliexpress.ru/item/1005004687429739.html?sku_id=12000030101513797&spm=.list.5.371b2aa3ztIT9A). Опасения насчет того, что сопротивление кастомной нагрузки непрогнозируемо, снимается, так как в отличие от кулоновских схем здесь ток разряда не только задается, но и измеряется, а потому подсчет слитых ампер-часов более корректен.
### <p align="center">1-WIRE шина <a name="onewire"></a>
К прибору может быть подключена шина с разумным числом устройств, например термодатчиков типа DS1820 для контроля температуры батареи побаночно, или реле для включения/отключения чего-либо на основе [модуля с DS2413](https://aliexpress.ru/item/1005004840350201.html?spm=a2g0o.search.search_results.0.780d11bec3ngus&sku_id=12000030697056255). Интерфейс - DS2482-100S. Разъем RJ11-6 может быть вынесен на тыльную или боковую стенку прибора (как и карта памяти). Всё это может выглядеть так:
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/DS18D20_4.jpg) - пока это только в планах.

Осталась в закромах от старого заказа.
### <p align="center">Защита <a name="protection"></a>
#### Переполюсовка <a name="reverse_polarity"></a>
Защита от переполюсовки батареи - есть, на схеме не найдете.
Защита от переполюсовки питания - отсутствует, так как разъемы питания полярные.
#### Перегрузка <a name="overload"></a>
Защита от перегрузки по току заряда - есть.
Защита от перегрузки по току разряда - есть.
#### Искрогашение <a name="spark"></a>
Функция искрогашения при подключении батареи - есть.
### <p align="center">По мелочи <a name="small"></a>
Зуммер - активный. Выход DAC следовало бы оставить неподключенным для выхода на УНЧ речевых сообщений - хорошая мысля приходит опосля. Светодиод RGB 5 мм. Кнопка аппаратного сброса. Печатная плата в габарите Кулона-912, 113х128мм двусторонняя. Заказана на JLCPCB (гербер-файлы в соответствующей директории) 5 штук за 1200р, ожидаются с нетерпением. 
***
## <p align="center">Программный аспект <a name="soft"></a>
### <p align="center">Платформа<a name="soft_platform"></a>
Arduino как программная платформа предполагает широкое использование сторонних разработок в виде библиотек, как правило на безвозмездной основе. (Цена вопроса потому - время на поиск/подбор подходящей библиотеки).
### <p align="center">Дисплей<a name="128x160"></a>
Driver IC:ST7735S поддерживается многими библиотеками, в том числе и TFT_eSPI by Bodmer. К достоинству следует отнести подробную инструкцию по настройке для выбранного подключения. К сожалению кириллицы нет (а может быть уже есть).
### <p align="center">Клавиатура<a name="button"></a>
Для схемы с делителем напряжения и аналоговым входом применена библиотека ... точнее [публикация](http://samopal.pro/arduino-button-2/). Возможности вполне устраивают: различаются короткие и длинные нажатия, автоповтор. Тайминги задаются по каждой кнопке свои.
### <p align="center">Пид-регулятор<a name="pid"></a>
Пид-регулятор, реализованный в DRV, [FastPID](https://github.com/mike-matera/FastPID/tree/master/examples/VoltageRegulator). Данные передаются целочисленными и предвычисленными для сокращения времени обработки драйвером силовой части.

 ![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/PID_Compensation_Animated.gif)

Влияние изменения параметров PID (Kp,Ki,Kd) на переходную характеристику системы. 
Подбор коэффициентов - шаманство ещё то, тем более если в наличии только 5-кнопочная клавиатура. На прототипе удалось подобрать приемлемый способ.
### <p align="center">Сеть<a name="connect"></a>
На этапе разработки и отладки применен пакет [AutoConnect](https://github.com/Hieromon/AutoConnect) Заимствован "как есть", добавлен график тока и напряжения с автоматическим выбором диапазонов. 
### <p align="center">Протокол обмена с драйвером<a name="wake"></a>
Выбор протокола WAKE объясняется его минимальной избыточностью. Универсальные по этому параметру существенно проигрывают.
![](https://github.com/olmoro/MKlon2.8/blob/main/Documents/Img/UART_request.png)
Запрос и ответ по асинхронному каналу на скорости 230400 бод начинаются с кода 0xC0, далее следует код команды, количество передаваемых байт, заканчивается передачей контрольной суммы. Применяется стаффинг. На запрос или ответ дается 600 микросекунд максимум, чтобы не мешать измерениям (сдвоенный импульс ниже) и работе ПИД-регулятора. В нижней строке PWM управления силовым DC/DC. 
### <p align="center">Команды<a name="commands"></a>
Список команд насчитывает несколько десятков, в основном исследовательских. А в мирной жизни нужны не более десятка-двух - такие как считать напряжение, ток и состояние (причем в физических единицах или "попугаях" АЦП), включить, отключить, задать параметры и т.п. 
### <p align="center">АЦП <a name="adc"></a>
Слабенький собственный АЦП ESP32 мало пригоден для измерений, но с контролем клавиатуры и отслеживанием питающего напряжения справляется вполне.
### <p align="center">Утилиты<a name="tools"></a>
Список системных утилит - это по сути набор инструментов, которые используются при реализации пользовательских алгоритмов. Особенность их состоит в том, что в них заложена проверка, не допускающая разрушения прибора, ограничивая намерения разработчика алгоритма. Если пользователь хорошо представляет реализуемый алгоритм, то написать программу не сложнее, чем для ёлочной гирлянды, тем более, что один из реализованных режимов - шаблон с подробными пояснениями. Но уметь программировать в среде Arduino надо уверенно. На профессиональном уровне всё для этого уже решено.
***
## <p align="center">Технические характеристики MKlon2.8 (вариант SAMD21)<a name="specifications"></a>
### <p align="center">Режим заряда
    - Зарядный ток Iз, А ......................... 0.05 – БП .......... ±(0.005 Iз + 0.05)*
    - Шаг установки зарядного тока, А ............ 0.01 
    - Зарядное напряжение U, В ................... 1.0 – 18.0 ......... ±(0.005 U + 0.05)*
    - Шаг установки зарядного напряжения, В	...... 0.01
### <p align="center">Режим разряда
    - Разрядный ток Iр, А ........................ 0.05 – 9.0 ......... ±(0.005 Iр + 0.05)*
    - Шаг установки разрядного тока, А ........... 0.01
    - Максимальная рассеиваемая мощность, Вт ..... не менее 40
    - то же с внешней нагрузкой, Вт .............. не более 120
 \*  - уточняются по результатам испытаний
  БП - определяется внешним ИП, но не более 10А
### <p align="center">и наконец
    - Питание от внешнего AC/DC .................. ноутбучный 19 В (4.74 ... 9.5 А)
    - Максимальная потребляемая мощность ......... 200 В·А
    - Интерфейс .................................. 5 кнопок, USB, WiFi, BT, 1-WIRE
    - Поддержка датчиков температуры ............. до 6 штук внешних
    - Индикация .................................. RGB 1.8" 128 X 160 (IC:ST7735S)
    - Диагностика ................................ 2 разъема для логического анализатора
    - Встроенные часы реального времени .......... с автономным источником
    - Micro-SD карта ............................. предусмотрена
    - Защита по выходу ........................... переполюсовка, перегрузка по току, КЗ
    - Степень защиты корпуса ..................... IP20
    - Климатические факторы: ..................... ГОСТ 15150, УХЛ 4
	    - диапазон рабочих температур ............ от 5 до 40 °С
	    - относительная влажность воздуха ........ 80 % при температуре 25 °С
	    - атмосферное давление ................... От 84 до 106.7 кПа
    - Условия хранения:
	    - диапазон температур .................... От -25 до 55 °С
	    - относительная влажность воздуха ........ 95 % при температуре 30°С
    - Габаритные размеры корпуса ................. 153 х 85 х 215 мм
    - Масса без комплекта кабелей и внешнего ИП .. не более 0.8 кг
    - Средний срок службы ........................ 10 лет
    - Средняя наработка на отказ ................. 25000 ч
    - Цена ....................................... определяется самостоятельной сборкой
***
# <p align="center">FSM <a name="fsm"></a>
## <p align="center"> Finite State Machine или finite-state machine или конечный автомат, кому как нравится. 
"Это до предела упрощенная модель компьютера, имеющая конечное число состояний, которая жертвует всеми особенностями компьютеров такие как ОЗУ, постоянная память, устройства ввода-вывода и процессорными ядрами в обмен на простоту понимания, удобство рассуждения и легкость программной или аппаратной реализации." Поверим пока на слово.

### <p align="center"> Об одном способе реализации конечного автомата.
Идея состоит в том, что реализация каждого режима работы устройства должна производиться независимо от иных режимов, но использовать некий общий инструментарий, обеспечивающий безаварийный доступ к ресурсам прибора. Как говорил великий Х.Д.Милс: "Нахождение глубинной простоты в запутанном клубке сущностей - это и есть творчество в программировании." - не дословно, но близко к источнику. В свое время мне понадобилось не более двух месяцев, чтобы подавить в себе естественное отторжение и привести проект к виду, с которым комфортно и, главное, безопасно работать.

### <p align="center"> Конечный автомат, он же Finite State Mashine (FSM).
Любой или почти любой процесс можно представить в виде последовательности шагов от одного состояния к другому. Разработчик мало чего стоит, если не представляет себе все возможные состояния, число которых конечно - именно поэтому автомат и называют "конечным". Вдохновением можно запастись [здесь](https://chipenable.ru/index.php/programming-avr/item/90-realizatsiya-konechnogo-avtomata-state-machine.html). Способ несомненно хорош, Но вот синхронизировать данные двух структур... хвост может начать вилять собакой.

Как же будет выглядеть реализация конкретного режима, например простого заряда аккумуляторной батареи? Графически режим такого заряда может быть представлен так: идите от жирной точки вверху, в цветных бланках короткие примечания к состояниям.
![Заряд CC/CV](https://github.com/olmoro/MKlon2.8/blob/main/Documents/FSM/CC_CV_fsm.jpg)
Вырисовывается не так уж и много состояний - чуть более десятка. Слева - состояния ввода параметров с возможностью отказа от дальнейшего ввода и перехода на исполнение или выход. Справа - последовательность шагов заряда - подъем тока, удержание тока и удержание напряжения. В центре - состояние отложенного старта. Исходим из того, что этот режим заряда (CC/CV) у нас "в печёнках", у кого нет - представьте, что это алгоритм ёлочной гирлянды. 
Оформим каждое состояние соответствующим объявлением класса в общем поле имен CcCvFsm. Здесь же можно определить необходимые константы, свойственные для этого режима, чтобы всегда были "под рукой" в структурах, а в классах ничто не мешает определить свои локальные константы и переменные как private:

##### файл cccvfsm.h
```c++
#ifndef _CCCVFSM_H_
#define _CCCVFSM_H_

#include "mstate.h"

namespace CcCvFsm    // Поле имен для режима простого заряда
{
  struct MChConsts
  {
      // Пределы регулирования
      static constexpr float i_l =  0.2f;
      static constexpr float i_h = 12.2f;
      static constexpr float v_l = 10.0f;
      static constexpr float v_h = 16.0f;
  };

  struct MPidConstants
  {
      // Параметры регулирования
      static constexpr float outputMin            = 0.0f;
      static constexpr float outputMaxFactor      = 1.05f;     // factor for current limit
  };

  class MStart : public MState
  {      
    public:
      MStart(MTools * Tools);
      MState * fsm() override;
  };

  class MSetCurrentMax : public MState
  {
    public:  
      MSetCurrentMax(MTools * Tools);
      MState * fsm() override;
    private:
        // Пределы регулирования max тока
      static constexpr float above = 6.0f;
      static constexpr float below = 0.2f;
  };
 
  class MSetVoltageMax : public MState
  {
    public:  
      MSetVoltageMax(MTools * Tools);
      MState * fsm() override;
  };

  class MSetCurrentMin : public MState
  {
    public:    
      MSetCurrentMin(MTools * Tools);
      MState * fsm() override;
  };

  class MSetVoltageMin : public MState
  {
    public:    
      MSetVoltageMin(MTools * Tools);
      MState * fsm() override;
  };

  class MPostpone : public MState
  {
    public:  
      MPostpone(MTools * Tools);
      MState * fsm() override;
  };

  class MUpCurrent : public MState
  {
    public:  
      MUpCurrent(MTools * Tools);
      MState * fsm() override;
  };

  class MKeepVmax : public MState
  {
    public:
      MKeepVmax(MTools * Tools);
      MState * fsm() override;
  };

  class MKeepVmin : public MState
  {
    public:  
      MKeepVmin(MTools * Tools);
      MState * fsm() override;
  };

  class MStop : public MState
  {
    public: 
      MStop(MTools * Tools);
      MState * fsm() override;
  };

  class MExit : public MState
  {
    public:
      MExit(MTools * Tools);
      MState * fsm() override;
  };

};

#endif  // !_CCCVFSM_H_
```
Не трудно заметить, что каждое состояние (далее по тексту может именоваться как "шаг") представлено соответствующим классом, а методы единственной функцией fsm() - виртуальной. 
Классы состояний режима, как и структуры с константами имеют свое поле имен, так что в других режимах могут использоваться те же имена, что, согласитесь, удобно.  А что за классы MState и MTools? Дойдем и до них. А пока оценим самодокументированность кода.

Перейдем к реализации. Определения всех состояний не приводятся, они однотипны. Рассмотрим на примере двух-трёх. Пока обращайте внимание только на содержательную часть, принимая "оболочку" как данность. По возможности используются говорящие имена. О классах достаточно знать лишь основы. Доверьтесь профессионалу - это при мне прямо "из-под волос" выдал программист, до которого нам далеко.
Честно признаюсь - меня поначалу стошнило))
 Пока просто скользните взглядом, не вчитывайтесь, ощутите возможность окинуть одним взглядом режим заряда от начала и до конца.

##### файл cccvfsm.cpp
```c++
#include "cccvfsm.h"
#include "mtools.h"
#include "mboard.h"
#include "mdisplay.h"
namespace CcCvFsm
{
  // Состояние "Старт", инициализация выбранного режима работы (Заряд CCCV).
  MStart::MStart(MTools * Tools) : MState(Tools)
  {
      // Параметры заряда из энергонезависимой памяти, Занесенные в нее при предыдущих включениях, как и
      // выбранные ранее номинальные параметры батареи (напряжение, емкость).
      // Tools->setVoltageMax( ... ); Tools->setVoltageMin( ... ); и т.п.
      
      // Индикация подсказки по строкам дисплея
      Display->getTextMode( (char*) "   CC/CV SELECTED    " );
      Display->getTextHelp( (char*) "  P-DEFINE  C-START  " );
      Display->progessBarOff();
  }
  MState * MStart::fsm()
  {
    switch ( Keyboard->getKey() )
    {
      case MKeyboard::C_CLICK :                // Если короткое нажатие на "C"
        // Пересчет из параметров батареи в напряжения и токи
        Tools->setVoltageMax( MChConsts::voltageMaxFactor * Tools->getVoltageNom() );
        Tools->setVoltageMin( MChConsts::voltageMinFactor * Tools->getVoltageNom() );
        Tools->setCurrentMax( MChConsts::currentMaxFactor * Tools->getCapacity() );
        Tools->setCurrentMin( MChConsts::currentMinFactor * Tools->getCapacity() );
        return new MPostpone(Tools);           // Выбран переход в состояние отложенного старта
      case MKeyboard::P_CLICK :                // Если короткое нажатие на "P"
        return new MSetCurrentMax(Tools);      // Выбран переход в состояние уточнения настроек заряда.
      default:;
    }
    Display->voltage( Board->getRealVoltage(), 2 ); // Во второй строке дисплея показывать напряжение
    Display->current( Board->getRealCurrent(), 1 ); // В первой строке дисплея показывать ток
    return this;                               // Ничего не выбрано, оставаться в этом состоянии до выбора
  };


  // Состояние "Коррекция максимального тока заряда"."
  MSetCurrentMax::MSetCurrentMax(MTools * Tools) : MState(Tools)
  {
    // Индикация подсказки
    Display->getTextMode( (char*) "U/D-SET CURRENT MAX" );
    Display->getTextHelp( (char*) "  B-SAVE  C-START  " );
  }
  MState * MSetCurrentMax::fsm()
  {
    switch ( Keyboard->getKey() )             // Что нажато и как долго
    {
      case MKeyboard::C_LONG_CLICK :
        return new MStop(Tools);              // Переход в состояние стоп
      case MKeyboard::C_CLICK :            
        return new MPostpone(Tools);          // Отказ от дальнейшего ввода параметров - исполнение
      case MKeyboard::B_CLICK :            
        Tools->saveFloat( MNvs::nCcCv, MNvs::kCcCvImax, Tools->getCurrentMax() ); 
        return new MSetVoltageMax(Tools);     // Сохранить и перейти к следующему параметру
      case MKeyboard::UP_CLICK :
      case MKeyboard::UP_AUTO_CLICK :
        Tools->currentMax = Tools->upfVal( Tools->currentMax, MChConsts::i_l, MChConsts::i_h, 0.1f );
        break;             // Корректировать по короткому нажатию на +0.1, по удержанию - повторять +0.1
      case MKeyboard::DN_CLICK :
      case MKeyboard::DN_AUTO_CLICK :
        Tools->currentMax = Tools->dnfVal( Tools->currentMax, MChConsts::i_l, MChConsts::i_h, 0.1f );
        break;
      default:;
    }
    // Если не закончили ввод, то индикация введенного
    Display->voltage( Board->getRealVoltage(), 2 );
    Display->current( Tools->getCurrentMax(), 1 );
    return this;                               // и остаемся в том же состоянии
  };


  //... несколько состояний аналогичны и опущены


  // Состояние: "Подъем и удержание максимального тока"
  MUpCurrent::MUpCurrent(MTools * Tools) : MState(Tools)
  {   
    // Индикация подсказки
    Display->getTextMode( (char*) " UP CURRENT TO MAX " );
    Display->getTextHelp( (char*) "       C-STOP      " );
    // Обнуляются счетчики времени и отданного заряда
    Tools->clrTimeCounter();
    Tools->clrAhCharge();
    // Включение (показано схематично, команды драйверу)
    Tools->setComAmp( ток );
    Tools->setComVolt( напряжение );
    Tools->setComGo();
  }     
  MUpCurrent::MState * MUpCurrent::fsm()
  {
    Tools->chargeCalculations();              // Подсчет отданных ампер-часов.
    // После пуска короткое нажатие кнопки "C" производит отключение тока.
    if(Keyboard->getKey(MKeyboard::C_CLICK)) { return new MStop(Tools); }    
    // Проверка напряжения и переход на поддержание напряжения.
    if( Board->getRealVoltage() >= Tools->getVoltageMax() ) { return new MKeepVmax(Tools); }
      
    // Индикация фазы подъема тока не выше заданного
    Display->voltage( Board->getRealVoltage(), 2 );
    Display->current( Board->getRealCurrent(), 1 );
    Display->progessBarExe( MDisplay::GREEN );
    Display->duration( Tools->getChargeTimeCounter(), MDisplay::SEC );
    Display->amphours( Tools->getAhCharge() );
      
    return this;
  };

  // Третья фаза заряда - достигнуто снижение тока заряда ниже заданного предела.
  // Проверки различных причин завершения заряда.
  MKeepVmin::MKeepVmin(MTools * Tools) : MState(Tools)
  {
    // Индикация подсказки
    Display->getTextMode( (char*) " KEEP VOLTAGE MIN  " );
    Display->getTextHelp( (char*) "       C-STOP      " );
    // Порог регулирования по напряжению (схематично)
    Tools->setComVoltMin();         
  }     
  MState * MKeepVmin::fsm()
  {
    Tools->chargeCalculations();        // Подсчет отданных ампер-часов.
    // Окончание процесса оператором.
    if (Keyboard->getKey(MKeyboard::C_CLICK)) 
    { return new MStop(Tools); }       
    // Здесь возможны проверки других условий окончания заряда
    // if( ( ... >= ... ) && ( ... <= ... ) )  { return new MStop(Tools); }
    // Максимальное время заряда, задается в "Настройках"
    if( Tools->getChargeTimeCounter() >= ( Tools->charge_time_out_limit * 36000 ) ) 
    { return new MStop(Tools); }
    Tools->setComVolt( указываем напряжение в милливольтах );           // Регулировка по напряжению
    Display->progessBarExe( MDisplay::MAGENTA );
    Display->duration( Tools->getChargeTimeCounter(), MDisplay::SEC );
    Display->amphours( Tools->getAhCharge() );
    return this;
  };


 // Состояние: "Завершение заряда"
  MStop::MStop(MTools * Tools) : MState(Tools)
  {
    Tools->shutdownCharge();
    Display->getTextHelp( (char*) "              C-EXIT " );
    Display->getTextMode( (char*) "   CC/CV CHARGE OFF  " );
    Display->progessBarStop();
  }    
  MState * MStop::fsm()
  {
    switch ( Keyboard->getKey() )
    {
      case MKeyboard::C_CLICK :
        return new MExit(Tools);
      default:;
      
      //Display->progessBarOff();
    }
    return this;
  };

  // Состояние: "Индикация итогов и выход из режима заряда в меню диспетчера" 
  MExit::MExit(MTools * Tools) : MState(Tools)
  {
    Tools->shutdownCharge();
    Display->getTextHelp( (char*) "              C-EXIT " );
    Display->getTextMode( (char*) "   CC/CV CHARGE OFF  " );
    Display->progessBarOff();
  }    
  MState * MExit::fsm()
  {
    switch ( Keyboard->getKey() )
    {
      case MKeyboard::C_CLICK :
        Display->getTextMode( (char*) "    CC/CV CHARGE     " );
        Display->getTextHelp( (char*) " U/D-OTHER  B-SELECT " );
        return nullptr;                             // Возврат к выбору режима
      default:;
    }
    return this; // до нажатия кнопки "С" удерживается индикация о продолжительности и отданном заряде.
  };
};
// !Конечный автомат режима простого заряда (CCCV).
```
Вот она! глубинная простота. Про всякие там "поздние связывания" нам знать не обязательно. Но то, что определение класса состояния начинается с конструктора (помним, что конструктор не возвращает никаких значений) - это инициализация состояния,  а далее следует определение объявленной ранее виртуальной функции, то есть что исполняется на этом шаге при каждом вызове. Короче. Любое отдельно взятое состояние будет выглядеть понятно. Получится думать не "галактикой", а одним и только одним состоянием в каждый момент.
Есть одно "но", связанное с тем, что конструктор нового состояние создается до выхода из предыдущего. Не вдаваясь в объяснения - здесь так делать можно:
```c++
// Состояние: "..."

  MName::MMName(MTools * Tools) : MState(Tools)
  {   
    // Это конструктор, здесь инициализация состояния
    // Используя методы из MTools выполните то, что требуется исполнить при переходе в это
    // состояние из какого-то иного состояния. Учтите, что конструктор ничего не возвращает.
  }
    
  MName::MName * MName::fsm()
  {
    // Это определение и вызов функции, здесь описывается методами MTools что надо выполнять
    // вслед за инициализацией и при каждом вызове этого состояния операционной системой.
    // Если при каждом вызове состояния что-то безусловно меняется, например индикация,
    // то укажите здесь.

    // В порядке приоритета при необходимости приведите проверки условий, при выполнении
    // которых выполняется запрос перехода в иное выбранное состояние, например

    if( условие = true ) { return new MName2(Tools); }

    // Если ни одно из условий не выполняется, то запрашивается возврат в это же состояние.
    // Однако если в этом случае опять-таки что-то меняется, задаем  здесь.

    return this;
    // return nullptr;   // Или для выхода из последнего состояния к выбору иного режима
  };
```
Как вы заметили, выделенные строки одинаковы во всех состояниях, радость-то какая))

Определения состояний расположены в произвольном порядке. И связаны только через return this, return name или return nullptr, которые выполняются при следующем обращении операционной системы к задаче. Какой? Не всё сразу. В итоге: определения можно располагать в произвольном порядке, копировать при необходимости из других режимов не заботясь о повторении имен. Избыточность? Зато головной боли меньше. Кстати, реализация режима, взятого для примера, занимает в памяти всего лишь 0,2%.

#### Теперь базовый класс MState:

##### файл mstate.h
```c++
#ifndef _MSTATE_H_
#define _MSTATE_H_

class MTools;
class MBoard;
class MDisplay;
class MKeyboard;

class MState
{
  public:
    MState(MTools * Tools);
    virtual ~MState(){}
    virtual MState * fsm() = 0;

  protected:
    MTools    * Tools    = nullptr;
    MBoard    * Board    = nullptr;
    MDisplay  * Display  = nullptr;
    MKeyboard * Keyboard = nullptr;
};

#endif // !_MSTATE_H_
```
Функция fsm() объявлена виртуальной и в файлах реализации режимов наследуется как виртуальная, поэтому там "virtual" не обязателен, да и "override" добавлен исключительно для читабельности.

файл mstate.cpp
```c++
#include "mstate.h"
#include "mtools.h"

MState::MState(MTools * Tools) :
  Tools(Tools),
  Board(Tools->Board),
  Display(Tools->Display),
  Keyboard(Tools->Keyboard) {}
```

Вы не находите, что это шедевр? Не мой - профессионала в этом деле.   ***Я не бездействовал, я сразу на капу нажал.***  
Попросил сделать максимально удобно из двух возможных вариантов для непрограммиста, но с навыками программирования (Во! как сказал - это я про себя). Кстати, если интересует почему все имена классов начинаются на одну и ту же букву - так это наше, фамильное)).

Далее по порядку:
MTools - класс, где состедоточено большая часть инструментария. Предполагается, что это пишет разработчик аппаратной части проекта, хорошо осведомленный в том, что можно, а за какие рамки заходить нельзя.
В отдельные классы оформлены (исторически так получилось)  описания и управление некоторыми ресурсами аппаратной части проекта - MBoard, MDisplay, MKeyboard. К ним вернусь позже.

На очереди класс MDispatcher, который отвечает за выбор режима работы прибора посредством меню. Но сначала в конструкторе - инициализация всего-всего.  Будете искать в Setup() привычные init(); - не ищите, конструктор класса по сути это и есть init().

##### файл dispatcher.h
```c++
#ifndef _DISPATCHER_H_
#define _DISPATCHER_H_

class MTools;
class MBoard;
class MDisplay;
class MState;

class MDispatcher
{
  public:
    enum MODES
    {
      OPTIONS = 0,    // режим ввода настроек (не отключаемый)
      TEMPLATE,       // шаблон режима
      DCSUPPLY,       // режим источника постоянного тока
      PULSEGEN,       // режим источника импульсного тока
      CCCVCHARGE,     // режим заряда "постоянный ток / постоянное напряжение"
      PULSECHARGE,    // режим импульсного заряда
      RECOVERY,       // режим восстановления
      STORAGE,        // режим хранения
      DEVICE,         // режим заводских регулировок
      SERVICE         // режим Сервис АКБ
    };

  public:
    MDispatcher(MTools * tools);

    void run();
    void delegateWork();
    void textMode(int mode);

  private:
    MTools    * Tools;
    MBoard    * Board;
    MDisplay  * Display;
    MState    * State = 0;

    bool latrus = false;
    int mode = CCCVCHARGE;
};

#endif //_DISPATCHER_H_
```
 В начале, как и ранее было показано, идет конструктор класса. В данном случае выполняет роль инициализации всего-всего. Константы ... кто видел где константы??? Да где же им быть - в объявлении класса. Тут есть как свои достоинства, так и недостатки.


##### файл dispatcher.cpp
```c++
#include "mdispatcher.h"
#include "nvs.h"
#include "mtools.h"
#include "mboard.h"
#include "mkeyboard.h"
#include "mdisplay.h"

#include "modes/templatefsm.h"
// ...
#include "modes/cccvfsm.h"
#include "modes/servicefsm.h"

#include <string>

MDispatcher::MDispatcher(MTools * tools): Tools(tools), Board(tools->Board), Display(tools->Display)
{
    char sLabel[ MDisplay::MaxString ] = { 0 };
    strcpy( sLabel, "  OLMORO ** ELTRANS  " );
    Display->getTextLabel( sLabel );

    latrus = Tools->readNvsBool( MNvs::nQulon, MNvs::kQulonLocal, true );
    mode   = Tools->readNvsInt ( MNvs::nQulon, MNvs::kQulonMode, 0 );   // Индекс массива

    textMode( mode );
    Tools->powInd = Tools->readNvsInt  ( MNvs::nQulon, MNvs::kQulonPowInd, 3);
    // Индекс массива с набором батарей 3
    Tools->akbInd = Tools->readNvsInt  ( MNvs::nQulon, MNvs::kQulonAkbInd, 3);
    Tools->setVoltageNom( Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonAkbU, Tools->akb[3][0]));
    Tools->setCapacity( Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonAkbAh, Tools->akb[3][1]) );

    Tools->postpone = Tools->readNvsInt( MNvs::nQulon, MNvs::kQulonPostpone,  3 );

    // Калибровки измерителей 
    Board->voltageMultiplier  = Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonVmult,   1.00f );
    Board->voltageOffset      = Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonVoffset, 0.00f );
    Board->currentMultiplier  = Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonImult,   1.40f );
    Board->currentOffset      = Tools->readNvsFloat( MNvs::nQulon, MNvs::kQulonIoffset, 0.00f );
}

void MDispatcher::run()
{
  // Индикация при инициализации процедуры выбора режима работы
  Display->voltage( Board->getRealVoltage(), 2 );
  Display->current( Board->getRealCurrent(), 1 );

  // Выдерживается период запуска для вычисления амперчасов
  if (State)
  {
    // rabotaem so state mashinoj
    MState * newState = State->fsm();     
    if (newState != State)                  //state changed!
    {
      delete State;
      State = newState;
    }
    //esli budet 0, na sledujushem cikle uvidim
  }
  else //state ne opredelen (0) - vybiraem ili pokazyvaem rezgim
  {
    if (Tools->Keyboard->getKey(MKeyboard::UP_CLICK))
    {
      if (mode == (int)SERVICE) mode = OPTIONS;
      else mode++;
      textMode( mode );
    }

    if (Tools->Keyboard->getKey(MKeyboard::DN_CLICK))
    {
      if (mode == (int)OPTIONS) mode = SERVICE;
      else mode--;
      textMode( mode );
    }

    if (Tools->Keyboard->getKey(MKeyboard::B_CLICK))
    {
      // Запомнить крайний выбор режима
      Tools->writeNvsInt( MNvs::nQulon, "mode", mode );

      switch (mode)
      {
        case OPTIONS:     State = new OptionFsm::MStart(Tools);     break;
          // несколько режимов опущены
        case CCCVCHARGE:  State = new CcCvFsm::MStart(Tools);       break;
        case SERVICE:     State = new ServiceFsm::MStart(Tools);    break;
        default:          break;
      }
    } // !B_CLICK
  }
}

void MDispatcher::textMode(int mode)
{
  char sMode[ MDisplay::MaxString ] = { 0 };
  char sHelp[ MDisplay::MaxString ] = { 0 };

  switch(mode)
  {
    case OPTIONS:
      sprintf( sMode, "OPTIONS: BATT.SELECT," );
      sprintf( sHelp, "CALIBRATION,TIMER ETC" );
    break;

    case CCCVCHARGE:
      sprintf( sMode, "    CC/CV CHARGE:    " );
      sprintf( sHelp, " U/D-OTHER  B-SELECT " );
    break;

      // ...
    case SERVICE:
      sprintf( sMode, "  BATTERY SERVICE:   " );
      sprintf( sHelp, " ADJUSTING THE DEVICE" );
    break;

    default:
      sprintf( sMode, "  ERROR:             ");
      sprintf( sHelp, "  UNIDENTIFIED MODE  " );
    break;
  }

  Display->getTextMode( sMode );
  Display->getTextHelp( sHelp );
}
```
Диспетчер выполнят две функции: первая - работа с меню до запуска выбранного режима, вторая - инициализация состояния и вызов виртуальной функции, определенной в классе этого состояния. Функция run() диспетчера проверяет номер состояния, который возвращается активным состоянием на ноль (nullptr) - это означает выход из режима в меню выбора. При ненулевом значении и отличным номером инициируется новое состояние, иначе будет исполнена та же функция, что и при предыдущем вызове естественно без инициализации. Всё тривиально просто. Но исполнителя требуется в первую очередь аккуратность.
Большую часть диспетчера занимает отправка на дисплей строк меню. Какие-то фоновые функции можно выполнить и здесь, в диспетчере, но лучше под них выделить отдельную задачу для RTOS и сбагрить её кому-то. И обратите внимание, как запускается fsm диспетчера - пригодится для реализации неотключаемых процессов.


Задачи RTOS. Хотите вы или нет, но с операционной системой реального времени Free RTOS придется подружиться. Разработчики Expressif постарались максимально облегчить жизнь программиста. Учебники по Free RTOS - в помощь, но надо иметь ввиду, что учебники писались для одноядерных процессоров, а ESP32 имеет два ядра. И блокировать, например, оба не есть хорошо. Рекомендуется для задач обслуживания радиотехнического блока использовать одно ядро, а для целевой программы - другое. Оформить сказанное не просто, а очень просто. Многое в настройках RTOS уже сделано за нас, тем более, если используется SDK от Expressif да ещё и под Ардуиной.  Уверяю, что скоро вы забудете, что ваш код исполняется под ОС. А вот без каких данных не обойтись - так это временные параметры процессов. Монопольно занимать одной задачей более 13 миллисекунд - моветон. Система отработает рестарт. На каждую задачу отводится 1 миллисекунда, потом обрабатывается другая задача. Иногда нельзя допустить перерыва в обработке ... впрочем это азы - отправляю к учебнику.
Вот так выглядит инициализация RTOS и разбиение нашего функционала на задачи. Некоторая особенность реализации вызвана ардуиновским делением файла main.cpp на setup() и loop(). Профи оценят.

##### файл main.cpp
```c++
#include "mboard.h"
#include "mcommands.h"
#include "mdisplay.h"
#include "mtools.h"
#include "mdispatcher.h"
#include "mconnmng.h"
#include "mmeasure.h"
#include "connectfsm.h"

static MBoard      * Board      = 0;
static MDisplay    * Display    = 0;
static MTools      * Tools      = 0;
static MCommands   * Commands   = 0;
static MMeasure    * Measure    = 0;
static MDispatcher * Dispatcher = 0;
static MConnect    * Connect    = 0;

void connectTask ( void * );
void displayTask ( void * );
void coolTask    ( void * );
void mainTask    ( void * );
void measureTask ( void * );
void driverTask  ( void * );

void setup()
{
  Display    = new MDisplay();
  Board      = new MBoard(Display);
  Tools      = new MTools(Board, Display);
  Commands   = new MCommands(Board);
  Measure    = new MMeasure(Tools);
  Dispatcher = new MDispatcher(Tools);
  Connect    = new MConnect(Tools);

  // Выделение ресурсов для каждой задачи: память, приоритет, ядро.
  // Все задачи исполняются ядром 1, ядро 0 выделено для радиочастотных задач - BT и WiFi.
  xTaskCreatePinnedToCore ( connectTask, "Connect", 10000, NULL, 1, NULL, 1 );
  xTaskCreatePinnedToCore ( mainTask,    "Main",    10000, NULL, 2, NULL, 1 );
  xTaskCreatePinnedToCore ( displayTask, "Display",  5000, NULL, 2, NULL, 1 );
  xTaskCreatePinnedToCore ( coolTask,    "Cool",     1000, NULL, 2, NULL, 1 );
  xTaskCreatePinnedToCore ( measureTask, "Measure",  5000, NULL, 2, NULL, 1 );
  xTaskCreatePinnedToCore ( driverTask,  "Driver",   5000, NULL, 2, NULL, 1 );
}

void loop() {}                            // Это тоже задача, пустая в данном случае

// Задача подключения к WiFi сети (полностью заимствована как есть)
void connectTask( void * )
{
  while(true)
  {
    Connect->run();
    // Период вызова задачи задается в TICK'ах, TICK по умолчанию равен 1мс.
    vTaskDelay( 10 / portTICK_PERIOD_MS );
  }
  vTaskDelete( NULL );
}

// Задача выдачи данных на дисплей
void displayTask( void * )
{
  while(true)
  {
    Display->runDisplay(
                        Board->Overseer->getCelsius(),
                        Tools->getAP() );
    vTaskDelay( 250 / portTICK_PERIOD_MS );
  }
  vTaskDelete( NULL );
}

// Задача управления системой теплоотвода.
void coolTask( void * )
{
  while (true)
  {
    Board->Overseer->runCool();
    vTaskDelay( 200 / portTICK_PERIOD_MS );
  }
  vTaskDelete( NULL );
}

// Задача обслуживает выбор режима работы и
// управляет конечным автоматом выбранного режима вплоть да выхода из него
void mainTask ( void * )
{
  while (true)
  {
    // Выдерживается период запуска для вычисления амперчасов. Если прочие задачи исполняются в     // порядке очереди, то эта точно по таймеру - через 0,1с.
    portTickType xLastWakeTime = xTaskGetTickCount();
    Dispatcher->run();
    vTaskDelayUntil( &xLastWakeTime, 100 / portTICK_PERIOD_MS );    // период 0,1с
  }
  vTaskDelete( NULL );
}

// Задача управления измерениями
void measureTask( void * )
{
  while (true)
  {
    Measure->run();
    vTaskDelay( 10 / portTICK_PERIOD_MS );
  }
  vTaskDelete(NULL);
}

void driverTask( void * )
{
  while (true)
  {
    Commands->doCommand();
    vTaskDelay( 100 / portTICK_PERIOD_MS );
  }
  vTaskDelete(NULL);
}
```
  Согласитесь - ничего сложного и запутанного в реализации конечного автомата по этому способу нет.

Всё. Успехов!
                               Версия от   28 января 2021 года                                       
                               редакция    2 декабря 2022 года                                       


![moro logo](https://github.com/olmoro/MKlon2.8/blob/main/Documents/FSM/moro_logo.jpg)

***
## <p align="center">Полезные ссылки<a name="useful_links"></a>
- [OSS](https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
- [Протокол обмена](http://leoniv.diod.club/articles/wake/wake.html)
- [Проекты на ESP32](https://randomnerdtutorials.com/projects-esp32/)
- [Как создать проект](https://dzen.ru/media/kotyara12/sozdanie-platformio--espidf-proekta-i-nastroika-platformioini-6324c68fb3d4c87d20ee80a6)
- [Как строятся графики](https://www.chartjs.org/)
- [Использование памяти в ESP32](https://dzen.ru/media/kotyara12/ispolzovanie-pamiati-v-esp32-63294a246a97da509e279eab)
***
## <p align="center"> About Me<a name="about"></a>
🚀 I'm a full stack developer urk2t@yandex.ru
